#!/usr/bin/env bash
#
#	srvr - an http server in bash using netcat
#

# vars
dir="$(cd "$(dirname "$BASH_SOURCE")" && pwd)"
pid="$$"
port="8080"
index="$1"
status="$2" && [ -z "$status" ] && status="200"
request="$dir/request"
response="$dir/response"

# usage
[ -z "$index" ] && echo "please specify a file to serve" >&2 && exit 1
[ ! -f "$index" ] && echo "file does not exist: $index" >&2 && exit 1

# go time
serve() {
  
  # trap ctrl-C
  trap "echo -n ' '; quit" SIGTERM SIGINT SIGQUIT SIGKILL
  
  # load the file to serve into memory
  index="$(cat "$index")"
  
  # make some fifos
  mkfifo request
  mkfifo response
  
  # start listening
  echo "listening on $port"
  listen
}

listen() {
  cat response | netcat -l -p "$port" > request &
  handle
}

handle() {
  
  # read request
  while read line
  do
    
    # log to stdout
    echo "$line"
    
    # only read up to first empty line
    test "${#line}" = 1 && break
  done < request
  
  # respond
  echo -e "HTTP/1.1 $status\r\n\r\n$index" > response
  
  # killing netcat seems to be the 
  # only way to close the connection
  close
  
  # start listening again
  listen
}

# kills all child processes
close() {
  while read process
  do
    child="$(echo "$process" | sed "s/[ ]*\([^ ]*\).*/\1/")"
    if [ "$child" != "$pid" ]
    then
      kill "$child" 2> /dev/null
    fi
  done < <(ps -o pid -o pgid -o command | grep "$pid")
}

quit() {
  
  # kill children
  close
  
  # remove fifos
  rm -rf request
  rm -rf response
  
  echo "bye!"
  exit 0
}

# start serving
serve
