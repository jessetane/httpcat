#!/usr/bin/env bash
#
# httpcat - an http server in bash using netcat
#

# vars
dir="$(cd "$(dirname "$BASH_SOURCE")" && pwd)"
pid="$$"
port="80"
status="200"
request="$dir/request"
response="$dir/response"

get_options() {
  i=1
  for arg in "$@"
  do
    if [ -n "$capture" ]
    then
      eval "$capture=\"$arg\""
      unset capture
    elif [ "$arg" = "-p" ]
    then
      capture="port"
    else
      case "$i" in
        1) index="$arg";;
        2) status="$arg";;
      esac
      ((i++))
    fi
  done
}

serve() {
  
  # usage
  [ -z "$index" ] && echo "please specify a file to serve" >&2 && exit 1
  [ ! -f "$index" ] && echo "$index: file does not exist" >&2 && exit 1
  
  # trap ctrl-C
  trap "echo -n ' '; quit" SIGTERM SIGINT SIGQUIT SIGKILL
  
  # netcat implemntations may vary...
  uname | grep -q "Darwin" && osx=true || osx=false
  
  # load the file to serve into memory
  index="$(cat "$index")" || quit 1
  
  # make some fifos
  mkfifo request
  mkfifo response
  
  # start listening
  echo "listening on $port"
  listen
}

listen() {
  if [ $osx = true ]
  then
    cat response | nc -l "$port" > request &
  else
    cat response | netcat -l -p "$port" > request &
  fi
  handle
}

handle() {
  got_request=false
  
  # read request
  while read line
  do
    got_request=true
    
    # log to stdout
    echo "$line"
    
    # only read up to first empty line
    test "${#line}" = 1 && break
  done < request
  
  # if we didn't get a request, there was an error
  [ $got_request = false ] && quit 1
  
  # respond
  echo -e "HTTP/1.1 $status\r\n\r\n$index" > response
  
  # killing netcat seems to be the 
  # only way to close the connection
  close
  
  # start listening again
  listen
}

# kills all child processes
close() {
  while read process
  do
    child="$(echo "$process" | sed "s/[ ]*\([^ ]*\).*/\1/")"
    if [ "$child" != "$pid" ]
    then
      kill "$child" 2> /dev/null
    fi
  done < <(ps -o pid -o pgid -o command | grep "$pid")
}

quit() {
  
  # kill children
  close
  
  # remove fifos
  rm -rf request
  rm -rf response
  
  # runtime error
  [ -n "$1" ] && exit "$1"
  
  # graceful
  echo "bye!"
  exit 0
}

# parse input
get_options "$@"

# start serving
serve
